#!/bin/bash
# An init.d script for running a Node.js process as a service using Forever as
# the process monitor. For more configuration options associated with Forever,
# see: https://github.com/nodejitsu/forever
#
# Live:              This shell script takes care of starting and stopping the Kaltura kLive Recorder service
#
# chkconfig: 2345 85 15
# description: Kaltura Live Recorder

### BEGIN INIT INFO
# Provides:          liveRecorder
# Required-Start:    $local_fs $remote_fs $network
# Required-Stop:     $local_fs $remote_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# X-Interactive:     true
# Short-Description: Start/stop Kaltura Live Recorder
### END INIT INFO

###
# extend callable functions from "functions" script
###

. /opt/rh/python27/enable

NAME=liveRecorder
LOG_DIR=/var/log
PID_DIR=/var/run
KLIVE_RECORDER_PREFIX=/opt/kaltura/liveRecorder/latest
STATUS_FUNCTION=status
PYTHON=python2.7

if [ -r /etc/defaults/${NAME} ]; then
    echo ". /etc/defaults/${NAME}"
    . /etc/defaults/${NAME}
fi

if [ -r /etc/rc.d/init.d/functions ]; then
   echo ". source /etc/rc.d/init.d/functions"
   . /etc/rc.d/init.d/functions
elif [ -r /lib/lsb/init-functions ]; then
   echo ". /lib/lsb/init-functions"
   . /lib/lsb/init-functions
   STATUS_FUNCTION=status_of_proc
else
    echo "Error, no function found for checking if ${NAME} is running. either not running in CentOS/Ubuntu or wrong path"
fi

# these lines added especially for QA
if [ ! -r ${KLIVE_RECORDER_PREFIX} ]; then
    SCRIPT_DIR=$(dirname $(readlink -f $0))
    KLIVE_RECORDER_PREFIX=${SCRIPT_DIR}/../../
    echo "KLIVE_RECORDER_PREFIX=${KLIVE_RECORDER_PREFIX}"
fi

LOG_DIR="${KLIVE_LOG_DIR}/${NAME}"
PIDFILE="${KLIVE_PID_DIR}/${NAME}.pid"
LOGFILE="${LOG_DIR}/${NAME}-service.log"
APPLICATION_PATH=${KLIVE_RECORDER_PREFIX}/main.py
RETVAL=0

createFolders() {
	[ -d ${LOG_DIR} ] || mkdir -p ${LOG_DIR}
	SHARED_APP_DIR=$(python ${SCRIPT_DIR}/getRecordingBaseDir.py)
	echo "Creating folders in ${SHARED_APP_DIR} for ${HOSTNAME}"
	if [ -d  ${SHARED_APP_DIR} ] ; then 
		mkdir -p ${SHARED_APP_DIR}/${HOSTNAME}/{UploadTask/{incoming,failed,processing},ConcatenationTask/{failed,processing}}
		[ -L ${SHARED_APP_DIR}/${HOSTNAME}/ConcatenationTask/incoming ] || ln -s ${SHARED_APP_DIR}/incoming ${SHARED_APP_DIR}/${HOSTNAME}/ConcatenationTask/incoming
	else
		echo "can't find ${SHARED_APP_DIR}, cannot start, check mounts"
		exit 2 
	fi
}

start() {
    echo "starting liveRecorder..."
    local __modules="schedule m3u8 poster psutil Crypto"
    for module in ${__modules}; do
         python -c "import ${module}"
        [ $? -ne 0 ] && echo "Missing ${module} pip module." && exit 3
    done
    createFolders || exit 4
    check_pid_status "-p ${PIDFILE}"
    if [ $? -eq 0 ]; then
        echo "${NAME} already running"
    else
        echo "Starting ${NAME}"
        python ${APPLICATION_PATH} >> ${LOGFILE}  2>&1 &
        RETVAL=$?
        echo $! > ${PIDFILE}
        if [ ${RETVAL} -eq 0 ]; then
			echo "started ${NAME} with PID $(cat ${PIDFILE})"
		else
			echo "starting ${NAME} failed. Please see ${LOGFILE}"
		fi
	fi
}

stop() {
    echo "stopping liveRecorder..."
    if [ -f ${PIDFILE} ]; then
        local __pid=$( cat ${PIDFILE} )
        echo "Shutting down ${NAME}"
        kill ${__pid} >> ${LOGFILE}
        check_pid_status "-p ${PIDFILE}"
	    if [ $? -eq 0 ]; then
	        echo "failed to stop ${NAME}, ${__pid}"
            killApp ${__pid}
            return 1
        else
            echo "${NAME}, ${__pid}, successfully stopped"
            rm -f ${PIDFILE}
        fi
    else
        echo "${NAME} is not running"
    fi
}

restart() {
    stop
    start
}

###
# check whether process is running based on /proc/[pid]/exe
###
my_status() {
    check_pid_status "-p ${PIDFILE}"
    RETVAL=$?
}

killApp() {
	local __pid=$1
    echo "Aggressively kill all ${NAME} process, ${__pid}"
    pkill -f ${APPLICATION_PATH}
    rm -f ${PIDFILE}
}

check_pid_status() {

    case ${STATUS_FUNCTION} in
        status)
            status $1
        ;;
        status_of_proc)
            status_of_proc $1 ${APPLICATION_PATH} ${PYTHON}
        ;;
        *)
            echo "check_pid_status failed, status function '${STATUS_FUNCTION}' is unsupported"
        ;;
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    status)
        my_status
        ;;
    restart)
        restart
        ;;
    *)
        echo "Usage: {start|stop|status|restart}"
        exit 1
        ;;
esac
exit ${RETVAL}
